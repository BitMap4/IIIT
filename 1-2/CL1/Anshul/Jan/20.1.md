Extra Class (Monday on Saturday)
*Crowd-Sourced Data* is data that is already abundant and available.

# **DATA**


**Data Licenses**
[About CC Licenses - Creative Commons](https://creativecommons.org/share-your-work/cclicenses/)Licenses are very important before taking the data. Ensure that you are not violating the copyrights. Take appropriate permissions from the data owners.
Ex. wikipedia data has a CC-BY license. This means you can use it if you give the credits to the source. (i.e.: by-line).
All papers today require a paragraph on the ethical considerations.
Do not distribute any data that is pirated.


The first step of NLP is your (research) problem (statement). 
Ex. Opinion Mining is my purpose.

**Methods of NLP**
Let us say I want to answer questions. I have two choices.
1. Data is already available, now use this data to derive patterns in QnA
2. I use my QnA knowledge, supply it the data (not QnAs).

**Inductive Methods**
There is no presumed knowledge of the data.
Start without pre-conception or pre-knowledge.
Begin by collecting observations or producing data.
After sufficient quantity, start making generalizations.
After many attempts at generalizations, make (induce) a new hypothesis.
This is known as the corpus-driven method.

**Deductive**
A hypothesis is made first. We apply these hypotheses  to the data.
This is also known as the corpus-based method.


Both of these methods may be hybridized.

Theory-->Hypotheses-->Data-->Observations


**Corpus Cleaning**

The data is in an unstructured format. We begin by structuring it.
**Regular Expressions** (RegEx)
It is a formal language for specifying text strings. RegEx can do simple text tokenization or processing. Python regexes.
NLTK, INLTK.
Ex. Very simple find and replace like in vi. 
Capitalization is an important feature of latin-script languages.

`/[wW]oodchuck` in vi returns all Woodchuck and woodchuck occurences.
`/[A-Z]` any capital letters
`/[a-z]` any small letters
`/[0-9]` any digits
`/[^A-Z]` negation, i.e. not any capitals
`/[^aeiouAEIOU]y` find all the letters which end with a consonant followed by the letter 'y'
`/([ab]+)` one or more instances of any of 'a' or 'b' $\rightarrow$ 'a', 'aa', 'ab', 'bbbababb', etc.
`/([gsh]*)`zero or more instances of any of the letters in it
`/([ac]?)` one or zero instances ie 'a' or 'c' or nothing
`/beg.n` begin, begun, began
`/colou?r` color or colour
`/o?esophagus` oesophagus or esophagus
`/summari[sz]e` summarize or summarise
`/^[a-z]$` any occurrence of a single isolated small letter.
`/the` may miss capitalizations
`/[Tt]he` may return Theories
`/[^a-zA-z][Tt]he[^a-zA-z]` correctly gives the
global regular expression: grep
`s/color/colour` replace color with colour (substitute)

`s/([0-9]/<\1>` put all the instances of single digits in <> `\1` refers to the first variable
`/?:(some|a few) (cats|people) like some \1`
now, `\1` refers to `(cats|people)` and not the first group because it is a non capturing group.
I.e. it will match
'some cats like some people'
or 'some cats like some cats'
but not 'some cats like some apples'
and neither 'some cats like some some'

Prompt engineering includes regexing all possible phrases of input.

**Heaps/Hardens Law**
A *Type* is an element of the vocabulary.
A *Token* is an instance of that type in running text.
English is an inflectional language. So the type-token ratio will be lesser than in Hindi, and even lesser than agglutinative languages like Dravidian languages.

Ex. "A rose is a rose is a rose." has 9 tokens

'rose' x 3
'a' x3
'is' x2
'.' x1

$N$ = number of tokens
$V$ = number of types (i.e. entire vocabulary)

every text has a particular writer (s), a specific time, variety, language, and function (etc.).
It is important to include a diverse corpus so that the model 

diasynchronous studies

**Assignment**
Take a corpus, write a code to clean it, use regex to tokenize it. Normalize word formats, segment sentences and words and find the 



Accuracy, precision --> minimize false positives
Coverage, Recall --> minimize false negatives



| Type | Grammar | Accepted by | ex. pluralize ox |
| ---- | ---- | ---- | ---- |
| 0 | Unrestricted | Recognized by Turing Machine | oxen |
| 1 | Context Sensitive | Linear Bound Automata | oxes |
| 2 | Context Free | Push Down Automata | oxs |
| 3 | Regular | Finite Automata | what?!! |

If it is more than type 3, i.e., mathematically, if it is not even a regular language, it is not considered a language. 